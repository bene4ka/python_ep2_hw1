#
# Задание на закрепление знаний по модулю CSV. Написать скрипт, осуществляющий выборку определенных данных из
# файлов info_1.txt, info_2.txt, info_3.txt и формирующий новый «отчетный» файл в формате CSV.
#
# Как мне кажется, способ реализации, требуемый в задании не вполне рационален, например, как вариант вместо четырех
# списков с данными, списка main_data и т.д. можно было создать словарь, где ключевыми значениями бы являлись
# заголовки, а данными по ключу - полученные из текстовых файлов значения. Затем, в качестве строк CSV-файла
# вписать все ключи и итерируясь по значениям ключей - строки с данными.
#
import re
import csv
from os import listdir


def get_data():
    """Функция создает переменную с заголовком, затем пустые списки для получения в них данных из файла и
    пустой результирующий список. Затем, используя итерацию по списку тестовых файлов, находящихся в текущей
    директории, открывает файлы на чтение и используя метод списков extend добавляет в списки необходимые значения
    с помощью регулярных выражений. После этого выполняется составление результирующего списка с данными и его
    добавление в список с заголовком.
    """

    def find_txt_fnames():
        """Получает имена текстовых файлов в текущей директории для дальшейшей по ним итерации.
        """
        fnames = listdir('.')
        return [filename for filename in fnames if filename.endswith('.txt')]

    # Создаем список переменных для дальнейшего использования. Заголовок задаем заранее, т.к. он известен;
    # списки, которые будем использовать в дальнейшем только объявляем.
    main_data = [['Изготовитель системы', 'Название ОС', 'Код продукта', 'Тип системы']]
    values_list = []

    os_prod_list = []
    os_name_list = []
    os_code_list = []
    os_type_list = []

    # Проходим в цикле по списку файлов, используя подфункцию find_txt_fnames(), заполняем списки данными
    # из кажого файла.
    for file in find_txt_fnames():
        f = open(file, 'r', encoding='windows-1251')
        s = f.read()

        os_prod_list.extend(re.compile(r'Изготовитель системы:\s*(.*?) *\n').findall(s))
        os_name_list.extend(re.compile(r'Название ОС:\s*(.*?) *\n').findall(s))
        os_code_list.extend(re.compile(r'Код продукта:\s*(.*?) *\n').findall(s))
        os_type_list.extend(re.compile(r'Тип системы:\s*(.*?) *\n').findall(s))

    # Т.к. данные необходимо размещать в соответствии с заголовком, создаем результирующий список
    # проходя циклом по всем i-тым элементам каждого спика с данными. В качестве количества итераций
    # взята длина первого списка с данными, заранее предполагая, что проблем с данными, получаемыми
    # не будет. Разумеется, можно было бы написать сверку релевантности количества значений в каждой
    # из переменных, но в рамках ДЗ этого не требуется.
    for i in range(0, len(os_prod_list)):
        prod_str = os_prod_list[i]
        name_str = os_name_list[i]
        code_str = os_code_list[i]
        type_str = os_type_list[i]

        values_list.append([prod_str, name_str, code_str, type_str])

    # Расширяем главный список, в котором пока что только заголовок будущего CSV-файла результирующими значениями.
    main_data.extend(values_list)

    # Возвращаем список.
    return main_data


def write_to_csv(link_to_csv):
    """Открывает файл с именем, который передается функции в
    качестве аргумента, и записывает в него полученные данные, вызывая функцию get_data().
    """

    # Файл открывается на запись с кодировкой utf-8, затем создается врайтер с использованием квотирования
    # нечисельных значений (соблюдаем хороший тон) и методом writerows записываем данные, которые возвращает\
    # функция получения данных.
    with open(link_to_csv, 'w', encoding='utf-8') as f_n:
        f_n_writer = csv.writer(f_n, quoting=csv.QUOTE_NONNUMERIC)
        f_n_writer.writerows(get_data())

    return None


def main():
    """Вызывает функцию write_to_csv(), передавая ей в качестве аргумента имя создаваемого файла"""
    write_to_csv('data.csv')


# Точка входа
if __name__ == '__main__':
    main()
